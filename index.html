<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Camera Animation</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.141.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>

    <!-- <script src="main.js" type="module"> </script> -->
    <h2
      style="
        color: #fff;
        width: 100%;
        text-align: center;
        position: fixed;
        z-index: 1000;
      "
    >
      PRESS SPACEBAR TO RESET VIEW
    </h2>
    <audio id="myAudio" src="./media/wind.mp3" autoplay loop></audio>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.2,
        1000
      );
      let renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      //   renderer.setClearColor("#e5e5e5");
      let mainPosition = {
        x: 1,
        y: 30,
        z: 30,
      };
      camera.position.set(mainPosition.x, mainPosition.y, mainPosition.z);
      // camera.position.x = 1;
      // camera.position.y = 20;
      // camera.position.z = 30;
      camera.rotation.x = -0.7;
      //   camera.lookAt(0,0,0);

      const textureLoader = new THREE.CubeTextureLoader();
      const texture = textureLoader.load([
        "./media/sky.jpg",
        "./media/sky.jpg",
        "./media/sky.jpg",
        "./media/sky.jpg",
        "./media/sky.jpg",
        "./media/sky.jpg",
      ]);

      scene.background = texture;

      //   //circle1
      //   const geometry = new THREE.SphereGeometry(1, 10, 10);
      //   var material = new THREE.MeshLambertMaterial({ color: 0xffcc00 });
      //   let circle1 = new THREE.Mesh(geometry, material);
      //   scene.add(circle1);
      //   circle1.position.set(-10,1,0);

      //   let circle2 = new THREE.Mesh(geometry, material);
      //   scene.add(circle2);
      //   circle2.position.set(10, 1, -9);

      //   let circle3 = new THREE.Mesh(geometry, material);
      //   scene.add(circle3);
      //   circle3.position.set(2, 1, 8);

      // const gridHelper = new THREE.GridHelper(20, 20);
      // scene.add(gridHelper);

      const gridSize = 20; // The size of the grid
      const sphereRadius = 0.5; // The radius of each sphere

      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
          }); // Initial color
          const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);

          // Position the spheres in a grid pattern
          sphereMesh.position.x = x - gridSize / 2 + 0.5;
          sphereMesh.position.z = y - gridSize / 2 + 0.5;

          scene.add(sphereMesh);
        }
      }

      const lightA = new THREE.AmbientLight(0x404040); // soft white light
      scene.add(lightA);

      var light = new THREE.PointLight(0xffffff, 1, 500);
      light.position.set(10, 0, 25);
      scene.add(light);

      //panToObject
      const panToObject = (cam, objPos) => {};
      //Raycaster
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      function onKeyDown(event) {
        if (event.code === "Space") {
          // Reset camera position to default
          gsap.to(camera.position, {
            duration: 1,
            x: mainPosition.x,
            y: mainPosition.y,
            z: mainPosition.z,
            ease: "power2.inOut",
          });
        }
      }

      function onMouseMove(event) {
        // Calculate normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onClick() {
        if (intersects.length > 0) {
          const intersectedSphere = intersects[0].object;
          const spherePosition = intersectedSphere.position;
          console.log(
            `Clicked sphere coordinates: (${spherePosition.x}, ${
              spherePosition.z * -1
            })`
          );
          gsap.to(camera.position, {
            duration: 1,
            x: spherePosition.x,
            y: spherePosition.y + 5,
            z: spherePosition.z + 5,
            ease: "power2.inOut",
          });
        } else {
          // Clicked on a non-intersecting object, return camera to default position
          gsap.to(camera.position, {
            duration: 1,
            x: mainPosition.x,
            y: mainPosition.y,
            z: mainPosition.z,
            ease: "power2.inOut",
          });
        }
      }

      window.addEventListener("mousemove", onMouseMove, false);
      window.addEventListener("click", onClick, false);
      window.addEventListener("keydown", onKeyDown, false);

      let loader = new THREE.GLTFLoader();
      let obj;
      const excludeObjects = []; // Array to hold objects to be excluded from raycasting

      loader.load(
        "media/old_map_3d_model/old_map_3d_model.glb",
        function (gltf) {
          obj = gltf.scene;

          // Set the desired scale factor
          let scaleFactor = 10; // Increase the scale by 2 times

          // Apply the scale to the object
          obj.scale.set(scaleFactor, scaleFactor, scaleFactor);

          scene.add(obj);
          excludeObjects.push(obj); // Add the object to the raycastObjects array
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          console.log("Model loaded successfully!");
        },
        function (error) {
          console.log("An error occurred:", error);
        }
      );

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      function initialAnimation() {
        const target = new THREE.Vector3(0, 0, 0); // Target position (center of the grid)
        const radius = 30; // Radius of the circular path
        const duration = 3; // Animation duration in seconds
        const angleIncrement = Math.PI / 2 / (60 * duration); // Angle increment for each frame

        let angle = Math.PI / 2; // Start at the final quarter of the circular motion

        function animateCamera() {
          const x = target.x + radius * Math.sin(angle);
          const z = target.z + radius * Math.cos(angle);

          camera.position.set(x, camera.position.y, z);
          camera.lookAt(target);

          angle -= angleIncrement; // Decrease the angle

          if (angle >= 0) {
            requestAnimationFrame(animateCamera);
          } else {
            // Lock camera position to the default position
            // camera.position.set(target.x, camera.position.y, target.z + 20);
            // camera.lookAt(target);

            // Smooth transition to the default position and rotation
            gsap.to(camera.position, {
              duration: 1,
              x: mainPosition.x,
              y: mainPosition.y,
              z: mainPosition.z,
              ease: "power2.inOut",
            });
            gsap.to(camera.rotation, {
              duration: 1,
              x: -0.7,
              y: 0,
              z: 0,
              ease: "power2.inOut",
            });
          }
        }

        animateCamera();
      }
      window.addEventListener("load", function () {
        initialAnimation();
      });

      const animate = () => {
        requestAnimationFrame(animate);

        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate intersections
        intersects = raycaster.intersectObjects(
          scene.children.filter((obj) => !excludeObjects.includes(obj))
        );

        // console.log(excludeObjects);

        // Reset colors of all spheres
        scene.traverse((object) => {
          if (object instanceof THREE.Mesh) {
            // console.log(object.parent);
            if(object.parent.isObject3D){
              object.material.color.set(0xff0000); // Reset to initial color
            }
          }
        });

        // Change color of the sphere being hovered over
        if (intersects.length > 0) {
          const intersectedSphere = intersects[0].object;
          intersectedSphere.material.color.set(0x00ff00); // Set to a different color
        }

        renderer.render(scene, camera);
      };
      animate();
    </script>
  </body>
</html>
